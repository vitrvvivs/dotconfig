#!/usr/bin/env python
import argparse
from time import time, sleep

PRETTY = '{name}  {downspeed:.%df} {prefix}  {upspeed:.%df} {prefix}'
SOURCE = "/proc/net/dev"
INTERVAL = 1
PREFIXES = {'K': 1024, 'M': 1024**2, 'G': 1024**3}

def get_key(header_str):
    key = []
    for prefix, attrs in zip(('i', 'rx_', 'tx_'), header_str.split('|')):
        key += [prefix + attr for attr in attrs.strip().split()]
    return key

def try_int(x):
    try:
        return int(x)
    except ValueError:
        return x

def line_to_status(line, key):
    status = {k: try_int(v) for k, v in zip(key, line.strip().split())}
    status["iface"] = status["iface"].rstrip(":")
    return status

def print_format(name, values, prefix="", bits=False, precision=3, pretty=False, follow=False):
    if prefix:
        values = {k: v / PREFIXES[prefix] * (8 if bits else 1) for k, v in values.items()}

    prefix += {True: 'b', False: 'B'}[bits]
    if follow: prefix += '/s'
    if pretty:
        print((PRETTY % (precision, precision)).format(name=name, prefix=prefix, downspeed=values["rx_bytes"], upspeed=values["tx_bytes"]), flush=True)
    else:
        print(name, values["rx_bytes"], values["tx_bytes"], flush=True)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-F', '--follow', action="store_true")
    parser.add_argument('-P', '--pretty', action="store_true")
    parser.add_argument('-c', '--combine', action="store_true")
    parser.add_argument('-f', '--format', default='b')
    parser.add_argument('-p', '--precision', type=int, default=3)
    args = parser.parse_args()

    # distinguish between Mb and MB
    if (args.format and args.format[-1] not in ('b', 'B')) or not args.format:
        args.format += 'b'
    args.bits = {'b': True, 'B': False}[args.format[-1]]
    args.format = args.format[:-1]

    # get the key
    source = open(SOURCE, 'r')
    data = source.read().strip().split('\n')
    key = get_key(data[1])

    # set the baseline for comparison
    previous_status = {}
    data = data[2:]
    i = 0
    while data:
        previous_status[i] = line_to_status(data.pop(0), key)
        i += 1

    # print the status
    while args.follow:
        start = time()

        # get new data
        source.seek(0)
        data = source.read().strip().split('\n')[2:]
        status = []

        while data:
            status.append(line_to_status(data.pop(0), key))

        # compare to previous data
        diff = {}
        for values in status:
            iface = values["iface"]
            if iface not in previous_status: continue
            previous_values = previous_status[iface]
            diff[iface] = {k: (values[k] - previous_values[k]) // INTERVAL for k in key[1:]}

        if "lo" in diff: del diff["lo"]

        if args.combine:
            diff = {"total": {k: sum(d[k] for d in diff.values()) for k in key[1:]}}

        # print diff
        for iface, values in diff.items():
            print_format(iface, values, prefix=args.format, bits=args.bits, precision=args.precision, pretty=args.pretty, follow=args.follow)

        # set up for next time
        previous_status = {values["iface"]: values for values in status}
        sleep(INTERVAL + time() - start)
    else:
        for index, status in previous_status.items():
            print_format(status.pop("iface"), status, prefix=args.format, bits=args.bits, precision=args.precision, pretty=args.pretty, follow=args.follow)
